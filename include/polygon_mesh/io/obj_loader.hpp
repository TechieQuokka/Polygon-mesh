#pragma once

#include <polygon_mesh/core/mesh.hpp>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdexcept>

namespace polygon_mesh {
namespace io {

// OBJ file format loader and saver
class OBJLoader {
public:
    // Load mesh from OBJ file
    template<typename T>
    static core::Mesh<T> load(const std::string& filepath) {
        std::ifstream file(filepath);
        if (!file.is_open()) {
            throw std::runtime_error("Failed to open OBJ file: " + filepath);
        }

        core::Mesh<T> mesh;
        std::vector<math::Vector3<T>> positions;
        std::vector<math::Vector3<T>> normals;
        std::vector<math::Vector2<T>> uvs;

        std::string line;
        while (std::getline(file, line)) {
            if (line.empty() || line[0] == '#') continue;

            std::istringstream iss(line);
            std::string prefix;
            iss >> prefix;

            if (prefix == "v") {
                // Vertex position
                T x, y, z;
                iss >> x >> y >> z;
                positions.emplace_back(x, y, z);
            }
            else if (prefix == "vn") {
                // Vertex normal
                T x, y, z;
                iss >> x >> y >> z;
                normals.emplace_back(x, y, z);
            }
            else if (prefix == "vt") {
                // Texture coordinate
                T u, v;
                iss >> u >> v;
                uvs.emplace_back(u, v);
            }
            else if (prefix == "f") {
                // Face
                std::vector<core::VertexId> face_vertices;
                std::string vertex_data;
                
                while (iss >> vertex_data) {
                    auto indices = parse_vertex_data(vertex_data);
                    
                    // Create or find vertex with these attributes
                    math::Vector3<T> pos = positions.at(indices.position - 1);
                    math::Vector3<T> normal(0);
                    math::Vector2<T> uv(0);
                    
                    if (indices.normal > 0 && indices.normal <= normals.size()) {
                        normal = normals[indices.normal - 1];
                    }
                    if (indices.uv > 0 && indices.uv <= uvs.size()) {
                        uv = uvs[indices.uv - 1];
                    }
                    
                    auto vertex_id = mesh.add_vertex(core::Vertex<T>(pos, normal, uv));
                    face_vertices.push_back(vertex_id);
                }
                
                if (face_vertices.size() >= 3) {
                    if (face_vertices.size() == 3) {
                        mesh.add_triangle(face_vertices[0], face_vertices[1], face_vertices[2]);
                    } else {
                        mesh.add_face(face_vertices);
                    }
                }
            }
        }

        return mesh;
    }

    // Save mesh to OBJ file
    template<typename T>
    static bool save(const std::string& filepath, const core::Mesh<T>& mesh) {
        std::ofstream file(filepath);
        if (!file.is_open()) {
            return false;
        }

        // Write header
        file << "# OBJ file generated by Polygon Mesh Library\n";
        file << "# Vertices: " << mesh.vertex_count() << "\n";
        file << "# Faces: " << mesh.face_count() << "\n\n";

        // Write vertices
        const auto& vertices = mesh.vertices();
        for (const auto& vertex : vertices) {
            file << "v " << vertex.position.x << " " 
                 << vertex.position.y << " " 
                 << vertex.position.z << "\n";
        }

        // Write normals if available
        bool has_normals = false;
        for (const auto& vertex : vertices) {
            if (vertex.has_normal()) {
                has_normals = true;
                break;
            }
        }

        if (has_normals) {
            file << "\n";
            for (const auto& vertex : vertices) {
                if (vertex.has_normal()) {
                    file << "vn " << vertex.normal.x << " "
                         << vertex.normal.y << " "
                         << vertex.normal.z << "\n";
                }
            }
        }

        // Write texture coordinates if available
        bool has_uvs = false;
        for (const auto& vertex : vertices) {
            if (vertex.has_uv()) {
                has_uvs = true;
                break;
            }
        }

        if (has_uvs) {
            file << "\n";
            for (const auto& vertex : vertices) {
                if (vertex.has_uv()) {
                    file << "vt " << vertex.uv.x << " " << vertex.uv.y << "\n";
                }
            }
        }

        // Write faces
        file << "\n";
        const auto& faces = mesh.faces();
        for (const auto& face : faces) {
            file << "f";
            for (auto vertex_id : face.vertices) {
                file << " " << (vertex_id + 1); // OBJ uses 1-based indexing
                
                // Add texture coordinate and normal indices if available
                const auto& vertex = vertices[vertex_id];
                if (has_uvs && vertex.has_uv()) {
                    file << "/" << (vertex_id + 1);
                } else if (has_normals) {
                    file << "/";
                }
                
                if (has_normals && vertex.has_normal()) {
                    file << "/" << (vertex_id + 1);
                }
            }
            file << "\n";
        }

        return true;
    }

private:
    struct VertexIndices {
        std::size_t position = 0;
        std::size_t uv = 0;
        std::size_t normal = 0;
    };

    static VertexIndices parse_vertex_data(const std::string& vertex_data) {
        VertexIndices indices;
        
        std::size_t pos = 0;
        std::size_t slash1 = vertex_data.find('/', pos);
        
        // Parse position index
        indices.position = std::stoul(vertex_data.substr(pos, slash1 - pos));
        
        if (slash1 != std::string::npos) {
            pos = slash1 + 1;
            std::size_t slash2 = vertex_data.find('/', pos);
            
            // Parse UV index (if present)
            if (slash2 != pos) { // Not an empty string between slashes
                std::string uv_str = vertex_data.substr(pos, slash2 - pos);
                if (!uv_str.empty()) {
                    indices.uv = std::stoul(uv_str);
                }
            }
            
            // Parse normal index (if present)
            if (slash2 != std::string::npos) {
                pos = slash2 + 1;
                if (pos < vertex_data.length()) {
                    indices.normal = std::stoul(vertex_data.substr(pos));
                }
            }
        }
        
        return indices;
    }
};

// Convenience functions
template<typename T>
core::Mesh<T> load_obj(const std::string& filepath) {
    return OBJLoader::load<T>(filepath);
}

template<typename T>
bool save_obj(const std::string& filepath, const core::Mesh<T>& mesh) {
    return OBJLoader::save(filepath, mesh);
}

} // namespace io
} // namespace polygon_mesh